<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.itjiaolong.top/"/>
  <updated>2018-04-08T07:50:35.744Z</updated>
  <id>http://blog.itjiaolong.top/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS 5种布局方案</title>
    <link href="http://blog.itjiaolong.top/2018/04/08/CSS-5%E7%A7%8D%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.itjiaolong.top/2018/04/08/CSS-5种布局方案/</id>
    <published>2018-04-08T07:46:45.000Z</published>
    <updated>2018-04-08T07:50:35.744Z</updated>
    
    <content type="html"><![CDATA[<p>以下5种布局方案均为两边固定中间自适应。</p><a id="more"></a><h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><pre><code>&lt;section&gt;    &lt;style&gt;        .float .left {            float: left;            width: 300px;            background-color: greenyellow;        }        .float .right {            float: right;            width: 300px;            background-color: greenyellow;        }        .float .center {            background-color: yellow;        }    &lt;/style&gt;    &lt;article class=&quot;float&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;center&quot;&gt;            &lt;h1&gt;浮动布局&lt;/h1&gt;        &lt;/div&gt;    &lt;/article&gt;&lt;/section&gt;</code></pre><h3 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h3><pre><code>&lt;section&gt;    &lt;style&gt;        .absolute&gt;div {            position: absolute;        }        .absolute .left {            left: 0;            width: 300px;            background-color: greenyellow;        }        .absolute .right {            right: 0;            width: 300px;            background-color: greenyellow;        }        .absolute .center {            left: 300px;            right: 300px;            background-color: yellow;        }    &lt;/style&gt;    &lt;article class=&quot;absolute&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;center&quot;&gt;            &lt;h1&gt;绝对定位布局&lt;/h1&gt;        &lt;/div&gt;    &lt;/article&gt;&lt;/section&gt;</code></pre><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><pre><code>    &lt;section&gt;    &lt;style&gt;        .flexbox {            display: flex;        }        .flexbox .left {            width: 300px;            background-color: greenyellow;        }        .flexbox .right {            width: 300px;            background-color: greenyellow;        }        .flexbox .center {            flex: 1;            background-color: yellow;        }    &lt;/style&gt;    &lt;article class=&quot;flexbox&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;center&quot;&gt;            &lt;h1&gt;flex布局&lt;/h1&gt;        &lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/article&gt;&lt;/section&gt;</code></pre><h3 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h3><pre><code>&lt;section&gt;    &lt;style&gt;        .table {            width: 100%;            display: table;            height: 100px;        }        .table&gt;div {            display: table-cell;        }        .table .left {            width: 300px;            background-color:greenyellow;        }        .table .right {            width: 300px;            background-color: greenyellow;        }        .table .center {            background-color: yellow;        }    &lt;/style&gt;    &lt;article class=&quot;table&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;center&quot;&gt;            &lt;h1&gt;表格布局&lt;/h1&gt;        &lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/article&gt;&lt;/section&gt;</code></pre><h3 id="grid网格布局"><a href="#grid网格布局" class="headerlink" title="grid网格布局"></a>grid网格布局</h3><pre><code>&lt;section&gt;    &lt;style&gt;        .grid {            display: grid;            width: 100%;            grid-template-rows: 100px;            grid-template-columns: 300px auto 300px;        }        .grid .left {            background-color: greenyellow;        }        .grid .right {            background-color: greenyellow;        }        .grid .center {            background-color: yellow;        }    &lt;/style&gt;    &lt;article class=&quot;grid&quot;&gt;        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;center&quot;&gt;            &lt;h1&gt;网格布局&lt;/h1&gt;        &lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;/article&gt;&lt;/section&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下5种布局方案均为两边固定中间自适应。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://blog.itjiaolong.top/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://blog.itjiaolong.top/tagstags/CSS/"/>
    
      <category term="布局" scheme="http://blog.itjiaolong.top/tagstags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript关于数组的一些方法整理</title>
    <link href="http://blog.itjiaolong.top/2018/04/08/JavaScript%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://blog.itjiaolong.top/2018/04/08/JavaScript关于数组的一些方法整理/</id>
    <published>2018-04-08T06:42:58.000Z</published>
    <updated>2018-04-08T07:45:08.867Z</updated>
    
    <content type="html"><![CDATA[<h3 id="会改变自身的方法"><a href="#会改变自身的方法" class="headerlink" title="会改变自身的方法"></a>会改变自身的方法</h3><ol><li><code>array.copyWithin（target, start [, end = this.length]）</code>用于在数组内的替换操作（有兼容问题）start和end允许为负值。</li><li><code>array.fill(value [,statrt = 0[, end = this.length]])</code>将数组中指定区间的所有元素的值替换为value，start和end允许为负值。</li><li><code>array.pop()</code>删除一个数组中的最后一个元素，并返回这个元素。</li><li><code>array.shift()</code>删除数组第一个元素，并返回这个元素。</li><li><code>array.push()</code>添加一个或者多个元素到数组末尾，并返回数组新的长度。</li><li><code>array.unshift()</code>在数组开头插入一个或者多个元素，并返回数组新长度。</li><li><code>array.reverse()</code>前后颠倒数组中元素的位置，第一个元素会成为最后一个。</li><li><code>array.sort([function(a, b)])</code>对数组的元素做原地排序，并返回这个数组。</li><li><code>array.splice(start, deleteCount[, item1[, item2...])</code>在任意的位置给数组添加或者删除任意个元素，返回被删除元素组成的数组，没有则返回空数组。</li></ol><a id="more"></a><h3 id="不会改变自身的方法"><a href="#不会改变自身的方法" class="headerlink" title="不会改变自身的方法"></a>不会改变自身的方法</h3><ol><li><code>array.concat(value1, value2.....)</code>将传入的数组或者非数组值与原数组合并，组成一个新的数组并返回。</li><li><code>array.includes(searchElement, [, fromIndex])</code>用来判断当前数组是否包含某指定的值，返回布尔值。</li><li><code>array.join([separator = &#39;,&#39;])</code>将数组中的所有元素连接成一个字符串（默认用逗号作为分隔符，如果separator是一个空的字符串，那么数组中的所有元素将被直接连接），如果元素是undefined或者null，则会转换为空字符串。</li><li><code>array.slice([begin = 0 [, end = this.length - 1]])</code>把数组中一部分的浅复制（shallow copy）存入一个新的数组对象中，并返回这个新的数组。</li><li><code>array.toString()</code>返回一个字符串，该字符串由数组中的每个元素的toString()返回值经调用join()方法连接，（由逗号隔开）组成。</li><li><code>array.toLocaleString()</code>返回一个字符串表示数组中的元素。数组中的元素将使用各自的toLocaleString方法转换成字符串，这些字符串将使用一个特定的语言环境的字符串（例如逗号）隔开。</li><li><code>array.indexOf(searchElement[, fromIndex = 0])</code>返回指定元素能在数组中找到的第一个索引值，否则返回-1。</li><li><code>array.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</code> 返回指定元素在数组中的最后一个索引，如果不存在则返回-1。从数组的后面向前排查。</li></ol><h3 id="数组遍历的方法"><a href="#数组遍历的方法" class="headerlink" title="数组遍历的方法"></a>数组遍历的方法</h3><ol><li><code>array.forEach((v, i, a) =&gt; {})</code>让数组的每一行都执行一次给定的函数，(v表示当前值，i当前索引，a数组本身)。</li><li><code>array.entries()</code>返回一个Array Iterator对象，该对象包含数组中每一个索引的键值对。</li><li><code>array.every(callback(v, i, a){})</code>callback只会为那些已经被赋值的索引调用，不会为那些删除或者从来没有被赋值的索引调用（返回一个Boolean值，即对每个元素callback函数结果作逻辑&amp;操作）。</li><li><code>array.some()</code> 使用方法和arr.evety()方法相同。（对每个元素的callback函数结果作逻辑||操作）。</li><li><code>array.filter((v, i, a) =&gt; {})</code>使用指定函数测试所有元素，并创建一个包含所有测试通过元素的新数组。（callback函数返回一个布尔值，true通过测试，callback只会在已经赋值的索引上调用，对于那些已经被删除或者从未被赋值的索引不会调用）。</li><li><code>array.find((v, i, a) =&gt;{})</code>目前有兼容性问题。返回数组中满足测试条件的第一个元素，如果没有满足条件的元素，则返回undefined。</li><li><code>array.keys()</code>返回一个数组索引的迭代器（类似于arr.entries()方法）。</li><li><code>array.map((v, i, a) =&gt; {})</code>返回一个由原数组中的每一个元素调用一个指定方法后的新返回值组成的新数组，map不修改调用它本身的原数组（当然可以在callback执行时改变原数组）。</li><li><code>array.reduce(callback[, initialValue])</code>该方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。<pre> previousValue:上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue: 数组中当前被处理的元素 index： index array： 调用的数组 如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</pre></li><li><code>array.reduceRight()</code>使用同<code>array.reduce()</code>相同，执行方向相反。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;会改变自身的方法&quot;&gt;&lt;a href=&quot;#会改变自身的方法&quot; class=&quot;headerlink&quot; title=&quot;会改变自身的方法&quot;&gt;&lt;/a&gt;会改变自身的方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;array.copyWithin（target, start [, end = this.length]）&lt;/code&gt;用于在数组内的替换操作（有兼容问题）start和end允许为负值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.fill(value [,statrt = 0[, end = this.length]])&lt;/code&gt;将数组中指定区间的所有元素的值替换为value，start和end允许为负值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.pop()&lt;/code&gt;删除一个数组中的最后一个元素，并返回这个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.shift()&lt;/code&gt;删除数组第一个元素，并返回这个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.push()&lt;/code&gt;添加一个或者多个元素到数组末尾，并返回数组新的长度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.unshift()&lt;/code&gt;在数组开头插入一个或者多个元素，并返回数组新长度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.reverse()&lt;/code&gt;前后颠倒数组中元素的位置，第一个元素会成为最后一个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.sort([function(a, b)])&lt;/code&gt;对数组的元素做原地排序，并返回这个数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.splice(start, deleteCount[, item1[, item2...])&lt;/code&gt;在任意的位置给数组添加或者删除任意个元素，返回被删除元素组成的数组，没有则返回空数组。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.itjiaolong.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.itjiaolong.top/tagstags/JavaScript/"/>
    
      <category term="Array" scheme="http://blog.itjiaolong.top/tagstags/Array/"/>
    
  </entry>
  
  <entry>
    <title>从输入域名到最后呈现经历的过程</title>
    <link href="http://blog.itjiaolong.top/2018/04/03/url/"/>
    <id>http://blog.itjiaolong.top/2018/04/03/url/</id>
    <published>2018-04-03T03:45:54.630Z</published>
    <updated>2018-04-08T07:48:16.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>1.浏览器的地址栏输入URL并按下回车。<br>2.浏览器查找当前URL是否存在缓存，并比较缓存是否过期。<br>3.DNS解析URL对应的IP。<br>4.根据IP建立TCP连接（三次握手）。<br>5.HTTP发起请求。<br>6.服务器处理请求，浏览器接收HTTP响应。<br>7.渲染页面，构建DOM树。<br>8.关闭TCP连接（四次挥手）。<br><a id="more"></a></p><h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h3><h4 id="HTTP缓存有多种规则，根据是否需要重新向服务器发起请求分为两种：强制缓存，对比缓存"><a href="#HTTP缓存有多种规则，根据是否需要重新向服务器发起请求分为两种：强制缓存，对比缓存" class="headerlink" title="HTTP缓存有多种规则，根据是否需要重新向服务器发起请求分为两种：强制缓存，对比缓存."></a>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求分为两种：强制缓存，对比缓存.</h4><pre><code>强制缓存：    cache-control：中的max-age保存一个相对时间。表示浏览器接收到文件之后，缓存在相对应的时间内均有效。如果同时存在cache-control和Expires,浏览器优先使用cache-control    Expires：是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没有失效就直接用缓存文件。该方法有一个问题，服务器可能和客户端时间不一致，因此该字段很少使用。 对比缓存：    last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新时间。下次浏览器请求资源时就发送if-modified-since字段。服务器用本地last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新的资源给浏览器，如果时间一致则返回304状态码，让浏览器继续使用缓存。    Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否变化，如果变化返回新资源，否则返回304。</code></pre><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>   在地址栏输入域名并不是最后资源所在的真实位置，域名只是一个IP地址的一个映射。</p><pre><code>1.首先浏览器会先查找本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。2.如果没有找到则会查找本地的DNS解析器缓存，如果找到则返回。3.如果还是没有找到则会查找本地DNS服务器，如果找到则返回。4.最后迭代查询，按根域服务器-&gt;顶级域名.cn-&gt;第二层域名-&gt;子域名的顺序找到IP地址</code></pre><h4 id="发起TCP的3次握手"><a href="#发起TCP的3次握手" class="headerlink" title="发起TCP的3次握手"></a>发起TCP的3次握手</h4><p>在解析域名之后，获取了服务器的IP地址，开始建立连接，这是由TCP协议完成的，主要通过三次握手进行连接。</p><pre><code>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SENT状态，等待服务器确认；第二层握手：服务器接收到syn包，必须确认客户端的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED(TCP连接成功)状态，完成三次握手。</code></pre><h4 id="建立TCP连接后发起http请求"><a href="#建立TCP连接后发起http请求" class="headerlink" title="建立TCP连接后发起http请求"></a>建立TCP连接后发起http请求</h4><pre><code>完整的HTTP请求包含请求行，请求头部，请求主体三个部分。(具体就不一一讲述了)</code></pre><h4 id="服务器响应http请求，浏览器接收响应"><a href="#服务器响应http请求，浏览器接收响应" class="headerlink" title="服务器响应http请求，浏览器接收响应"></a>服务器响应http请求，浏览器接收响应</h4><pre><code>服务器在收到浏览器发送的HTTP请求之后，会收到HTTP报文封装成HTTP的Request对象，并通过不同的web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。状态码主要包括以下部分：    1xx：指示信息-表示请求已接收，继续处理    2xx：成功-表示请求已被成功接收，理解，接收    3xx：重定向-要完成请求必须进行更进一步的操作    4xx：客户端错误-请求语法错误或请求无法实现    5xx：服务器端错误：服务器未能合法实现请求响应头主要由：cache-control、connection、date、pragma等组成。</code></pre><h4 id="浏览器解析html，页面渲染"><a href="#浏览器解析html，页面渲染" class="headerlink" title="浏览器解析html，页面渲染"></a>浏览器解析html，页面渲染</h4><p>在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本或图片时，会再次发生HTTP请求重复上述步骤。在收到css文件后对已经渲染的页面重新渲染，加入它们对应的样式，图片文件加载完立刻显示在相应的位置。在这一过程中可能会触发重绘或重排。</p><pre><code>reflow：也称作layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为reflow。repaint：中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候(例如：背景色，边框颜色，文字颜色等)，此时只需要应用新样式绘制这个元素就可以了。</code></pre><h4 id="四次挥手结束，关闭TCP连接"><a href="#四次挥手结束，关闭TCP连接" class="headerlink" title="四次挥手结束，关闭TCP连接"></a>四次挥手结束，关闭TCP连接</h4><p>通过四次挥手关闭连接(FIN ACK、ACK、FIN ACK、ACK)。</p><pre><code>第一次挥手：浏览器发完数据后，发生FIN请求断开连接第二次挥手：服务器发送ACK表示同意断开连接第三次挥手：服务器发送FIN请求断开连接第四次挥手：浏览器需要返回ACK表示同意断开</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;具体步骤&quot;&gt;&lt;a href=&quot;#具体步骤&quot; class=&quot;headerlink&quot; title=&quot;具体步骤&quot;&gt;&lt;/a&gt;具体步骤&lt;/h3&gt;&lt;p&gt;1.浏览器的地址栏输入URL并按下回车。&lt;br&gt;2.浏览器查找当前URL是否存在缓存，并比较缓存是否过期。&lt;br&gt;3.DNS解析URL对应的IP。&lt;br&gt;4.根据IP建立TCP连接（三次握手）。&lt;br&gt;5.HTTP发起请求。&lt;br&gt;6.服务器处理请求，浏览器接收HTTP响应。&lt;br&gt;7.渲染页面，构建DOM树。&lt;br&gt;8.关闭TCP连接（四次挥手）。&lt;br&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.itjiaolong.top/categories/HTTP/"/>
    
    
      <category term="http" scheme="http://blog.itjiaolong.top/tagstags/http/"/>
    
  </entry>
  
</feed>
